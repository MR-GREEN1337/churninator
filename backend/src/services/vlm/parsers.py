# backend/src/services/vlm/parsers.py
import re
from .base import VLMResponse, VLMResponseParser
from forge.utils.function_parser import extract_function_calls_from_text


class Stage2Parser(VLMResponseParser):
    """
    Parses the <think>...</think><code>...</code> format that our
    fine-tuned models (and properly prompted proprietary models) produce.
    This version is hardened to handle incomplete or missing XML tags.
    """

    def parse(self, text: str) -> VLMResponse:
        # Search for each tag independently, allowing for missing tags.
        thought_match = re.search(r"<think>(.*?)</think>", text, re.DOTALL)
        code_match = re.search(r"<code>(.*?)</code>", text, re.DOTALL)
        observation_match = re.search(
            r"<observation>(.*?)</observation>", text, re.DOTALL
        )
        friction_match = re.search(r"<friction>(.*?)</friction>", text, re.DOTALL)

        # Extract content if the tag exists, otherwise provide a default.
        thought = (
            thought_match.group(1).strip()
            if thought_match
            else "Warning: No thought provided by the model."
        )

        if code_match:
            code_content = code_match.group(1).strip()
            # Use our robust function parser to ensure it's a valid action
            parsed_actions = extract_function_calls_from_text(code_content)
            if parsed_actions:
                action = parsed_actions[0].to_string()
            else:
                action = f"TERMINATE('Parsing Error: Invalid action in code block: {code_content}')"
        else:
            action = (
                "TERMINATE('Parsing Error: No code block found in model response.')"
            )

        observation = observation_match.group(1).strip() if observation_match else ""

        friction_score = 0
        if friction_match is not None:
            group_val = friction_match.group(1)
            if group_val:
                digits = re.search(r"\d+", group_val)
                if digits:
                    try:
                        friction_score = int(digits.group())
                    except ValueError:
                        friction_score = 0

        return VLMResponse(
            thought=thought,
            action=action,
            observation=observation,
            friction_score=friction_score,
        )


class HuggingFaceGenericParser(VLMResponseParser):
    """
    A generic parser for Hugging Face Inference API models that might just
    return the action string. This is a fallback.
    """

    def parse(self, text: str) -> VLMResponse:
        # The HF API often wraps the final output
        if isinstance(text, list) and len(text) > 0 and "generated_text" in text[0]:
            text = text[0]["generated_text"]

        # This parser assumes the model was prompted to ONLY return an action.
        # It's less robust, but a necessary strategy for some models.
        parsed_actions = extract_function_calls_from_text(text)
        if parsed_actions:
            action = parsed_actions[0].to_string()
            thought = "Action generated by a generic HF model."
        else:
            action = f"TERMINATE('Parsing Error: Could not find a valid action in HF output: {text}')"
            thought = "Hugging Face model failed to produce a parsable action."

        return VLMResponse(thought=thought, action=action)


# You can add more parsers here, e.g., for specific model families
